<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <title>8 Puzzle</title>
    </head>
    <body>
        <canvas id="puzzle"></puzzle>

        <script>

        var PuzzleState = function(state, last, goal, cost) {
            this.state = state;
            this.last = last || null;
            this.goal = goal || null;
            this.cost = cost || 1;
            this.blank = 0;
            this.stepCost = null;

            this.sideLen = this.state.length;
            this.sides = range(this.sideLen);
            this.blankPos = this.findBlankPos();
            this.pathCost = this.calcPathCost();
        };

        PuzzleState.prototype.slideUp = function() {
            return this.swap(this.blankPos[0], this.blankPos[1] - 1);
        };

        PuzzleState.prototype.slideDown = function() {
            return this.swap(this.blankPos[0], this.blankPos[1] + 1)
        };

        PuzzleState.prototype.slideLeft = function() {
            return this.swap(this.blankPos[0] - 1, this.blankPos[1])
        };

        PuzzleState.prototype.slideRight = function() {
            return this.swap(this.blankPos[0] + 1, this.blankPos[1])
        };

        PuzzleState.prototype.validPos = function(col, row) {
            return (col >= 0 && col < this.sideLen && row >= 0 && row < this.sideLen);
        };

        PuzzleState.prototype.swap = function(col, row) {
            if (!this.validPos(col, row)) {
                return null;
            }

            var currentState = this.state;
            var newState = clone2d(currentState);
            newState[this.blankPos[0]][this.blankPos[1]] = newState[col][row]
            newState[col][row] = this.blank

            var nextPuzzleState = new PuzzleState(newState, this, this.goal);
            return nextPuzzleState;
        };

        // TODO(richard-to): This probably doesn't work
        PuzzleState.prototype.isGoal = function() {
            return this == this.goal;
        };

        PuzzleState.prototype.predictedCost = function() {
            return this.pathCost + this.calcStepCost();
        };

        PuzzleState.prototype.heuristic = function() {
            return 0;
        };

        PuzzleState.prototype.calcStepCost = function() {
            if (!this.stepCost) {
                this.stepCost = this.heuristic();
            }
            return this.stepCost;
        };

        PuzzleState.prototype.calcPathCost = function() {
            var pathCost = 0;
            if (this.last) {
                pathCost = this.cost + this.last.pathCost;
            }
            return pathCost;
        };

        PuzzleState.prototype.hasLast = function() {
            return this.last != null;
        };

        PuzzleState.prototype.printState = function() {
            for (var x = 0; x < this.state.length; ++x) {
                console.log(this.state[x]);
            }
        };

        PuzzleState.prototype.parity = function() {
            var parity = 0;
            var stateList = to1d(this.state);
            stateList.splice(stateList.indexOf(this.blank, 1));
            while (stateList.length > 0) {
                state = stateList.shift();
                for (var i = 0; i < stateList.length; ++i) {
                    if (state > state[i]) {
                        parity += 1;
                    }
                }
            }
            return (parity % 2 == 0) ? false : true;
        };

        PuzzleState.prototype.findBlankPos = function() {
            var state = this.state;
            var sides = this.sides;
            var blank = this.blank;
            for (var x = 0; x < sides; ++x) {
                for (var y = 0; y < sides; ++y) {
                    if (state[x][y] == blank {
                        return [x, y];
                    }
                }
            }
        };

        PuzzleState.prototype.__eq__(self, other):
                if isinstance(other, self.__class__):
                    return self.state == other.state
                else:
                    return False

        PuzzleState.prototype.__ne__(self, other):
                return not self.__eq__(other)

        PuzzleState.prototype.__hash__(self):
                return self.state.__hash__()

        var genRandPuzzle = function(side) {
            var size = side * side;
            while (true) {
                start = range(size);
                startState = to2d(start);
                startState = new PuzzleState(startState)

                goal = range(size)
                random.shuffle(goal)
                goalState = to2d(goal);
                goalState = PuzzleState(goalState)

                if (startState.parity() == goalState.parity()) {
                    startState.goal = goalState
                    return startState
                }
            }
        };

        var clone2d = function(list2d) {
            var list2dClone = [];
            for (var x = 0; x < list2d.length; ++x) {
                list2dClone[x] = list2d[x].slice(0);
            }
            return list2dClone;
        };

        var to1d = function(list) {
            var list1d = [];
            for (var x = 0; x < list.length; ++x) {
                for (var y = 0; y < list[x].length; ++y) {
                    list1d.push(list[x][y]);
                }
            }
            return list1d;
        };

        var to2d = function(list, side) {
            var list2d = [];
            for (var x = 0; x < side; ++i) {
                list2d[x] = [];
                for (var y = 0; y < side; ++y) {
                    list2d[x][y] = list[x * side + y];
                }
            }
            return list2d;
        };

        var range = function(n) {
            var a = [];
            while (n) {
                a.push(--n);
            }
            return a;
        };

        var shuffle = function(list_in) {
            var pick, temp;
            var list = list_in.slice(0);
            var i = list.length;
            while (--i > 0) {
                pick = Math.floor(Math.random() * i);
                temp = list[i];
                list[i] = list[pick];
                list[pick] = temp;
            }
            return list;
        };

        var scramble = function(image, ctx) {
            var missingBlock = Math.floor(Math.random() * 16);

            var size = 4;
            var blockX = Math.floor(image.width/4);
            var blockY = Math.floor(image.height/4);
            var blocks = [];

            for (var x = 0; x < size; ++x) {
                for (var y = 0; y < size; ++y) {
                    blocks.push(ctx.getImageData(x * blockX, y * blockY, blockX, blockY));
                }
            }
            blocks = shuffle(blocks);

            for (var x = 0; x < size; ++x) {
                for (var y = 0; y < size; ++y) {
                    ctx.putImageData(blocks.shift(), x * blockX, y * blockY);
                }
            }

            var missingBlock = Math.floor(Math.random() * 16);
            var x = Math.floor(missingBlock / size);
            var y = missingBlock % size;
            ctx.rect(x * blockX, y * blockY, blockX, blockY);
            ctx.fillStyle = 'black';
            ctx.fill();
        };

        var size = 3;
        var order =
        var canvas = document.getElementById('puzzle');
        var ctx = canvas.getContext('2d');

        var image = new Image();
        image.onload = function() {
            canvas.width = image.width;
            canvas.height = image.height;
            ctx.drawImage(image, 0, 0, image.width, image.height);
            scramble(image, ctx);
        };
        image.src = "images/trees.jpg";
        </script>

    </body>
</html>

